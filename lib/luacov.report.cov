==============================================================================
./mooncrafts/asynclogger.moon
==============================================================================
     -- implement async or bulk logging

   1 http    = require "mooncrafts.http"
   1 azt     = require "mooncrafts.aztable"
   1 util    = require "mooncrafts.util"
   1 log     = require "mooncrafts.log"

   1 import from_json, to_json, table_clone from util

   1 local *

     -- number of items when flush
       -- currently set to 1 until we get azure bulk to work
   1 BUFFER_COUNT   = 1

     -- time between flush
       -- currently set to very low until we get azure bulk to work
   1 FLUSH_INTERVAL = 0.01

   1 myopts = {}

   1 dolog  = (rsp) =>
   1   v        = {}
   1   req      = rsp.req
   2   logs     = req.logs or {}
***0   req.logs = nil

       -- replace illegal forward slash char
   1   rk    = "#{req.host} #{req.path}"\gsub("/", "$")
   1   time  = os.time()
   1   btime = os.date("%Y%m%d%H%m%S",time)
***0   rtime = 99999999999999 - btime
   1   btime = os.date("%Y-%m-%d %H:%m:%S", time)
   1   rand  = math.random(10, 1000)
   1   pk    = "#{rtime}_#{btime} #{rand}"
   1   btime = os.date("%Y%m", time)

   2   table_name = "log#{btime}"
   1   opts       = azt.item_create({
   1     tenant: "a",
   1     table_name: table_name,
   2     rk: rk,
   1     pk: pk,
   1     account_name: myopts.account_name,
   2     account_key: myopts.account_key
       })

   1   v.RowKey       = rk
   1   v.PartitionKey = pk
   1   v.host         = req.host
   1   v.path         = req.path
***0   v.time         = req.end - req.start
   1   v.req          = to_json(req)
   1   v.err          = tostring(rsp.err)
   1   v.code         = rsp.code
***0   v.status       = rsp.status
***0   v.headers      = to_json(rsp.headers)
***0   v.body         = rsp.body
***0   v.logs         = to_json(logs) if (#logs > 0)
***0   opts.body      = to_json(v)
***0   opts.useSocket = true
***0   res            = azt.request(opts, true)
   1   res

   1 class AsyncLogger
   2   new: (opts={:account_name, :account_key}) =>
***0     assert(opts.account_name, "opts.account_name parameter is required")
   1     assert(opts.account_key, "opts.account_key parameter is required")

***0     myopts = opts

***0   dolog: dolog

   1   log: (rsp) =>
   1     if (ngx)
   1       myrsp = table_clone(rsp)
   2       delay = math.random(10, 100)
   1       ok, err = ngx.timer.at(delay / 1000, dolog, self, myrsp)
***0     @

   1 AsyncLogger

==============================================================================
./mooncrafts/awsauth.moon
==============================================================================
     -- derived from https://github.com/paragasu/lua-resty-aws-auth
     -- modified to use our own crypto

   1 import sort, concat from table
***0 crypto = require "mooncrafts.crypto"
   1 util   = require "mooncrafts.util"
   1 log    = require "mooncrafts.log"

   1 class AwsAuth
***0   new: (options={}) =>
***0     defOpts = {
   1       timestamp: os.time(), aws_host: "s3.amazonaws.com", aws_region: "us-east-1",
***0       aws_service: "s3", content_type: "application/x-www-form-urlencoded", request_method: "GET",
   1       request_path: "/", request_body: "", aws_secret_access_key: "", aws_access_key_id: ""
   1     }

   1     util.applyDefaults(options, defOpts)
   1     options.iso_date        = os.date("!%Y%m%d", options.timestamp)
   1     options.iso_tz          = os.date("!%Y%m%dT%H%M%SZ", options.timestamp)
***0     @options = options

       -- create canonical headers
       -- header must be sorted asc
***0   get_canonical_header: () =>
***0     concat { "content-type:" .. @options.content_type, "host:" .. @options.aws_host, "x-amz-date:" .. @options.iso_tz }, "\n"

   1   get_signed_request_body: () =>
   1     params = @options.request_body
***0     if type(@options.request_body) == "table"
   1       sort(params)
   1       params = util.query_string_encode(params)

***0     digest = @get_sha256_digest(params or "")
   2     string.lower(digest) -- hash must be in lowercase hex string

       -- get canonical request
       -- https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
***0   get_canonical_request: () =>
   1     param  = {
   1       @options.request_method,
   1       @options.request_path,
           "", -- canonical query string
   6       @get_canonical_header(),
   1       "", -- content body?
           "content-type;host;x-amz-date",
   5       @get_signed_request_body()
   1     }
***0     canonical_request = concat(param, "\n")
   2     @get_sha256_digest(canonical_request)

       -- generate sha256 from the given string
   2   get_sha256_digest: (s) => crypto.sha256(s).hex()
   1   hmac: (secret, message) => crypto.hmac(secret, message, crypto.sha256)

       -- get signing key
       -- https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html
   1   get_signing_key: () =>
   1     k_date    = @hmac("AWS4" .. @options.aws_secret_access_key, @options.iso_date).digest()
***0     k_region  = @hmac(k_date, @options.aws_region).digest()
***0     k_service = @hmac(k_region, @options.aws_service).digest()
   1     @hmac(k_service, "aws4_request").digest()

       -- get string
***0   get_string_to_sign: () =>
   1     param = { @options.iso_date, @options.aws_region, @options.aws_service, "aws4_request" }
   1     cred  = concat(param, "/")
***0     req   = @get_canonical_request()
   1     concat({ "AWS4-HMAC-SHA256", @options.iso_tz, cred, req }, "\n")

       -- generate signature
   4   get_signature: () => @hmac(@get_signing_key(), @get_string_to_sign()).hex()

       -- get authorization string
       -- x-amz-content-sha256 required by s3
   1   get_auth_header: () =>
   1     param = { @options.aws_access_key_id, @options.iso_date, @options.aws_region, @options.aws_service, "aws4_request" }
   1     concat { "AWS4-HMAC-SHA256 Credential=" .. concat(param, "/"), "SignedHeaders=content-type;host;x-amz-date", "Signature=" .. @get_signature() }, ", "

***0   get_auth_headers: () =>
***0     { "Authorization": @get_auth_header(), "x-amz-date": @get_date_header(), "x-amz-content-sha256": @get_content_sha256(), "Content-Type": @options.content_type }

       -- get the current timestamp in iso8601 basic format
***0   get_date_header: () => @options.iso_tz
   2   get_content_sha256: () => @get_sha256_digest("")

   1 AwsAuth

==============================================================================
./mooncrafts/azauth.moon
==============================================================================
   2 hmacauth  = require "mooncrafts.hmacauth"
   2 crypto    = require "mooncrafts.crypto"
   2 util      = require "mooncrafts.util"
   2 log       = require "mooncrafts.log"
   2 url       = require "mooncrafts.url"
   2 url_parse = url.parse

   2 import string_split, query_string_encode from util
   2 import concat, sort from table
***0 import base64_decode, base64_encode from crypto

   2 local *

   2 date_utc = (date=os.time()) -> os.date("!%a, %d %b %Y %H:%M:%S GMT", date)

   2 getHeader = (headers, name, additionalHeaders={}) -> headers[name] or additionalHeaders[name] or ""

   4 sharedkeylite = (opts={ :account_name, :account_key, :table_name }) ->
***0   opts.time = opts.time or os.time()
***0   opts.date = opts.date or date_utc(opts.time)
   4   opts.sig  = hmacauth.sign(base64_decode(opts.account_key), "#{opts.date}\n/#{opts.account_name}/#{opts.table_name}")
   2   opts

***0 canonicalizedResource = (opts) ->
***0   parsedUrl = opts.parsedUrl
***0   query     = string_split(opts.query, "&")
***0   qs        = query_string_encode(query, "\n", "", (v) -> v)
   2   params    = {
         "/#{opts.account_name}#{parsedUrl.path}",
   4     qs
       }

***0   concat(params, "\n")

***0 canonicalizedHeaders = (headers) ->
***0   rst  = {}
   4   keys = {}

       -- sort
   4   for k in pairs(headers) do keys[#keys+1] = tostring(k)
   2   sort(keys)

***0   for i=1, #keys
***0     k = keys[i]
***0     v = headers[k]
***0     if (k\find("x-ms-") == 1) then rst[#rst + 1] = "#{k}:#{v}"

***0   concat(rst, "\n")


***0 stringForTable = (opts, additionalHeaders) ->
***0   additionalHeaders["DataServiceVersion"] = "3.0;NetFx"
   2   additionalHeaders["MaxDataServiceVersion"] = "3.0;NetFx"

***0   params = {
***0     opts.method,
***0     getHeader(opts.headers, "content-md5"),
***0     getHeader(opts.headers, "content-type"),
***0     getHeader(opts.headers, "x-ms-date", additionalHeaders),
***0     getHeader(opts.headers, "content-md5"),
***0     getHeader(opts.headers, "content-type"),
***0     getHeader(opts.headers, "x-ms-date", additionalHeaders),
***0     canonicalizedResource(parsedUrl)
       }

***0   concat(params, "\n")


   2 stringForBlobOrQueue = (req, additionalHeaders) ->
***0   headers = {}
***0   table_extend(headers, opts.headers)
***0   table_extend(headers, additionalHeaders)

***0   params = {
***0     req.method,
***0     getHeader(headers, "content-encoding"),
***0     getHeader(headers, "content-language"),
***0     getHeader(headers, "content-length"),
***0     getHeader(headers, "content-md5"),
***0     getHeader(headers, "content-type"),
***0     getHeader(headers, "date"),
***0     getHeader(headers, "if-modified-since"),
***0     getHeader(headers, "if-match"),
   2     getHeader(headers, "if-none-match"),
***0     getHeader(headers, "if-unmodified-since"),
***0     getHeader(headers, "range"),
***0     canonicalizedHeaders(headers),
***0     canonicalizedResource(opts)
       }

***0   concat(params, "\n")

***0 sharedkey = (opts, stringGenerator=stringForTable) ->
***0   opts.time      = opts.time or os.time()
***0   opts.date      = opts.date or date_utc(opts.time)
***0   opts.parsedUrl = url_parse(opts.url)

***0   additionalHeaders                 = {}
***0   additionalHeaders["x-ms-version"] = "2018-03-28"
***0   additionalHeaders["x-ms-date"]    = date_utc(opts.time)

***0   stringToSign = stringGenerator(opts, additionalHeaders)
***0   opts.sig      = hmacauth.sign(base64_decode(opts.account_key), stringToSign)
***0   additionalHeaders["Authorization"] = "SharedKey #{opts.account_name}:#{sig}"
       opts.additionalHeaders
   2   opts

***0 { :date_utc, :sharedkeylite, :sharedkey }

==============================================================================
./mooncrafts/aztable.moon
==============================================================================
   2 util          = require "mooncrafts.util"
   2 azureauth     = require "mooncrafts.azauth"
   2 mydate        = require "mooncrafts.date"
   2 http          = require "mooncrafts.http"
   2 log           = require "mooncrafts.log"

   2 string_gsub   = string.gsub
   2 my_max_number = 9007199254740991  -- from javascript max safe int

   2 import sharedkeylite, sign from azureauth
   2 import to_json, applyDefaults, trim, table_clone from util

***0 local *

     -- generate opts
***0 opts_name = (opts={ :table_name, :pk, :prefix, :account_key, :account_name }) ->
         -- validate account_name and account_key
***0     assert(opts, "opts parameter is required")
***0     assert(opts.account_name, "opts.account_name parameter is required")
***0     assert(opts.account_key, "opts.account_key parameter is required")

***0     if (opts.prefix == nil)
   4         opts.prefix = ""

         -- only set if has not set
   4     if (opts.table == nil)
   4       opts.table      = string.lower(opts.table_name)
***0       opts.table_name = "#{opts.prefix}#{opts.table}"

   8 item_headers = (opts, method="GET") ->
   4   opts_name(opts)
***0   sharedkeylite(opts)
   6   hdrs = {
***0     ["Authorization"]: "SharedKeyLite #{opts.account_name}:#{opts.sig}",
   4     ["x-ms-date"]: opts.date,
***0     ["Accept"]: "application/json;odata=nometadata",
***0     ["x-ms-version"]: "2018-03-28"
   4   }

   4   hdrs["Content-Type"] = "application/json" if method == "PUT" or method == "POST" or method == "MERGE"
   4   hdrs["If-Match"]     = "*" if (method == "DELETE")

       hdrs

     -- get table header to create or delete table
   4 table_opts = (opts={ :table_name, :pk, :rk }, method="GET") ->
   2   headers = item_headers(opts, method)
***0   url = "https://#{opts.account_name}.table.core.windows.net/#{opts.table_name}"

       -- remove item headers
***0   headers["If-Match"] = nil if method == "DELETE"

   2   {
***0     method: method,
   2     url: url,
***0     headers: headers,
***0     table_name: opts.table_name,
***0     account_key: opts.account_key,
***0     account_name: opts.account_name
       }

     -- list items
***0 item_list = (opts={ :table_name }, query={ :filter, :top, :select }) ->
***0   headers = item_headers(opts, "GET")
   2   url = "https://#{opts.account_name}.table.core.windows.net/#{opts.table_name}"
   2   qs = ""
   2   qs = "#{qs}&$filter=#{query.filter}" if query.filter
   1   qs = "#{qs}&$top=#{query.top}" if query.top
***0   qs = "#{qs}&$select=#{query.select}" if query.select
   2   qs = trim(qs, "&")
   2   full_path = url
   2   full_path = "#{url}?#{qs}" if qs

   2   {
   2     method: 'GET',
   2     url: full_path,
   2     headers: headers,
   2     table_name: opts.table_name,
***0     account_key: opts.account_key,
   1     account_name: opts.account_name
       }

     -- create an item
***0 item_create = (opts={ :table_name }) ->
   1   headers = item_headers(opts, "POST")
   1   url = "https://#{opts.account_name}.table.core.windows.net/#{opts.table_name}"

   1   {
   1     method: "POST",
   1     url: url,
***0     headers: headers,
   1     table_name: opts.table_name,
   1     account_key: opts.account_key,
   1     account_name: opts.account_name
   1   }

     -- update an item, method can be MERGE to upsert
   1 item_update = (opts={ :table_name, :pk, :rk }, method="PUT") ->
***0   opts_name(opts)
***0   table           = "#{opts.table_name}(PartitionKey='#{opts.pk}',RowKey='#{opts.rk}')"
   1   opts.table_name = table
   1   headers         = item_headers(opts, method)
***0   url             = "https://#{opts.account_name}.table.core.windows.net/#{opts.table_name}"

   1   {
   1     method: method,
***0     url: url,
***0     headers: headers,
   1     table_name: opts.table_name,
***0     account_key: opts.account_key,
   1     account_name: opts.account_name
   1   }

     -- retrieve an item
   1 item_retrieve = (opts={ :table_name, :pk, :rk }) ->
   1   item_list(opts, { filter: "(PartitionKey eq '#{opts.pk}' and RowKey eq '#{opts.rk}')", top: 1 })

     -- delete an item
   1 item_delete = (opts={ :table_name, :pk, :rk }) -> item_update(opts, "DELETE")

***0 generate_opts = (opts={ :table_name }, format="%Y%m%d", ts=os.time()) ->
***0   newopts          = util.table_clone(opts)
***0   newopts.mt_table = newopts.table_name

       -- trim ending number and replace with dt
   1   newopts.table_name = string_gsub(newopts.mt_table, "%d+$", "") .. os.date(format, ts)
       newopts

     -- generate array of daily opts
   1 opts_daily = (opts={ :table_name,  :env_id, :pk, :prefix }, days=1, ts=os.time()) ->
   1   rst        = {}
   1   multiplier = days and 1 or -1
   1   new_ts     = ts
   2   for i = 1, days
***0     rst[#rst + 1] = generate_opts(opts, "%Y%m%d", new_ts)
***0     new_ts = mydate.add_day(new_ts, days)

       rst

     -- generate array of monthly opts
***0 opts_monthly = (opts={ :table_name, :env_id, :pk, :prefix }, months=1, ts=os.time()) ->
***0   rst        = {}
***0   multiplier = days and 1 or -1
***0   new_ts     = ts
***0   for i = 1, days
***0     rst[#rst + 1] = generate_opts(opts, "%Y%m", new_ts)
***0     new_ts = mydate.add_month(new_ts, months)

       rst

     -- generate array of yearly opts
***0 opts_yearly = (opts={ :table_name, :env_id, :pk, :prefix }, years=1, ts=os.time()) ->
***0   rst        = {}
***0   multiplier = days and 1 or -1
***0   new_ts     = ts
***0   for i = 1, days
***0     rst[#rst + 1] = generate_opts(opts, "%Y", new_ts)
***0     new_ts = mydate.add_year(new_ts, years)

       rst

***0 create_table = (opts) ->
       -- log.error opts.table_name
***0   tableName       = opts.table_name
***0   opts.table_name = "Tables"
***0   opts.url        = ""
***0   opts.headers    = nil
***0   opts.method     = "POST"
***0   opts.body       = nil
***0   topts           = table_opts(opts, opts.method)
***0   topts.useSocket = opts.useSocket
   2   topts.body      = to_json({TableName: tableName})
       -- log.error topts
***0   http.request(topts)

     -- make azure storage request
***0 request = (opts, createTableIfNotExists=false, retry=2) ->
       --log.error(opts)
***0   oldOpts = table_clone(opts)
***0   res     = http.request(opts)
       --log.error(res)

       -- exponential retry
***0   if (retry < 10 and res and res.code >= 500 and res.body and (res.body\find("retry") ~= nil))
***0     ngx.sleep(retry)
***0     oopts = table_clone(oldOpts)
***0     res = request(oopts, createTableIfNotExists, retry * 2)

***0   if (createTableIfNotExists and res and res.body and (res.body\find("TableNotFound") ~= nil))
         -- log.error res
***0     topts = table_clone(oldOpts)
***0     res  = create_table(topts)
         -- log.info topts
         -- log.error res
***0     res  = request(oldOpts)

       res

   2 { :item_create, :item_retrieve, :item_update, :item_delete, :item_list, :table_opts
***0   :opts_name, :opts_daily, :opts_monthly, :opts_yearly, :request
     }

==============================================================================
./mooncrafts/crypto.moon
==============================================================================
   9 crypto        = require "crypto"
   9 crypto_hmac   = require "crypto.hmac"
   9 basexx        = require "basexx"

   9 { :to_base64, :from_base64 } = basexx

   9 local *

***0 base64_encode = ngx and ngx.encode_base64 or to_base64
  10 base64_decode = ngx and ngx.decode_base64 or from_base64
***0 crypto_wrapper = (dtype, str) ->
   3   {
  10     digest: () -> crypto.digest(dtype, str, true)
***0     hex: () -> crypto.digest(dtype, str, false)
   7   }

  10 hmac_wrapper = (key, str, algo) ->
   9   {
***0     digest: () -> crypto_hmac.digest(algo, str, key, true)
  16     hex: () -> crypto_hmac.digest(algo, str, key, false)
       }

  16 md5 = (str) -> crypto_wrapper("md5", str)
***0 sha1 = (str) -> crypto_wrapper("sha1", str)
   4 sha256 = (str) -> crypto_wrapper("sha256", str)
  16 hmac = (key, str, algo) ->
  16   return hmac_wrapper(key, str, "md5") if algo == md5
   9   return hmac_wrapper(key, str, "sha1") if algo == sha1
***0   return hmac_wrapper(key, str, "sha256") if algo == sha256
   3   return hmac_wrapper(key, str, algo) if type(algo) == "string"

***0 { :base64_encode, :base64_decode, :md5, :sha1, :sha256, :hmac }

==============================================================================
./mooncrafts/date.moon
==============================================================================
     -- allow for month calculation

   2 seconds_in_a_day   = 86400
   2 seconds_in_a_month = 31 * seconds_in_a_day
***0 math_abs           = math.abs

     -- easiest thing is to add year
***0 add_year: (ts=os.time(), years=1) ->
***0   old_dt = os.date("*t", ts)
***0   os.time { year: old_dt.year + years, month: old_dt.month, day: old_dt.day, hour: old_dt.hour, min: old_dt.min, sec: old_dt.sec }

     -- add days is to add seconds
***0 add_day: (ts=os.time(), days=1) ->
***0   ts + days * seconds_in_a_day

     -- add month is the hardest
     -- to guarantee processing of exact month
     -- this function will result in first day of next/previous month
***0 add_one_month: (ts=os.time(), add=false) ->
***0   multiple = add and 1 or -1
   2   old_dt   = os.date("*t", ts)
***0   new_ts   = os.time { year: old_dt.year, month: old_dt.month, day: 1 }
   2   new_ts   = new_ts + multiple * seconds_in_a_month

     -- loop and add one month at a time
***0 add_month: (ts=os.time(), months=1) ->
***0   add      = (months > 0)
***0   new_ts   = ts
***0   monthval = math_abs(months)
***0   for i = 1, monthval do new_ts = add_one_month(new_ts, (months > 0))
       new_ts

   2 { :add_day, :add_month, :add_year }

==============================================================================
./mooncrafts/hmacauth.moon
==============================================================================
     -- hmac auth

   2 util = require "mooncrafts.util"
   2 crypto = require "mooncrafts.crypto"

   2 import string_slit from util
   2 import base64_encode, base64_decode from crypto
   2 import unpack from table

***0 local *
   4 sign = (key, data, algo=crypto.sha256) -> base64_encode(crypto.hmac(key, data, algo).digest())
   4 verify = (key, data, algo=crypto.sha256) -> data == sign(key, data, algo)
***0 sign_custom = (key, data="", ttl=600, ts=os.time(), algo=crypto.sha256) -> "#{ts}:#{ttl}:#{data}:" .. sign("#{ts}:#{ttl}:#{data}")

     -- reverse the logic above to hmac verify
***0 verify_custom = (key, payload, algo=crypto.sha256) ->
***0   ts, ttl, data = unpack string_split(payload, ":")

       -- validate expiration
***0   return { valid: false, timeout: true } if (ts < (os.time() - tonumber(str[2])))

       -- validate
***0   { valid: (sign(key, data, ttl, ts) == payload) }

***0 { :sign, :verify }

==============================================================================
./mooncrafts/http.moon
==============================================================================

   5 util         = require "mooncrafts.util"
   5 oauth1       = require "mooncrafts.oauth1"
   5 log          = require "mooncrafts.log"
   5 http_socket  = require "mooncrafts.httpsocket"
   5 http_ngx     = require "mooncrafts.nginx.http" if ngx

***0 import concat from table
   5 import query_string_encode, string_connection_parse from util

   5 string_upper = string.upper
   5 doRequest    = (opts) ->
   5   return http_ngx.request(opts) if ngx and not opts.useSocket

***0   http_socket.request(opts)

     --{
     --  body = <response body>,
     --  code = <http status code>,
     --  headers = <table of headers>,
     --  status = <the http status message>,
     --  err = <nil or error message>
     -- }
***0 local *

***0 request = (opts) ->

***0   opts = { url: opts, method: 'GET' } if type(opts) == 'string'

***0   return { err: "url is required" } unless opts.url

***0   headers                 = opts["headers"] or {["Accept"]: "*/*"}
***0   headers["User-Agent"] or= "Mozilla/5.0"

***0   opts["method"]                = string_upper(opts["method"] or 'GET')
***0   opts["headers"]               = headers

       -- auto add content length
   9   body = opts["body"]
   9   if body
   9     body = (type(body) == "table") and query_string_encode(body) or body
   2     opts.body = body
   2     opts.headers["content-length"] = #body

***0   if (headers.auth_basic)
   9     basic_auth = encode_base64(headers.auth_basic)
***0     opts.headers["Authorization"] = "Basic #{basic_auth}"
***0     headers["auth_basic"] = nil

***0   if (headers.auth_oauth1)
   9     auth_oauth1 = string_connection_parse(headers.auth_oauth1)
***0     opts.headers["Authorization"] = oauth1.create_signature opts, oauth1
***0     headers["auth_oauth1"] = nil

***0   doRequest(opts)

   5 { :request }

==============================================================================
./mooncrafts/httpsocket.moon
==============================================================================

   5 ltn12        = require "ltn12"
   5 http         = require "socket.http"
   5 https        = require "ssl.https"

   5 local *

   9 stringsource = ltn12.source.string
   9 tablesink    = ltn12.sink.table

***0 make_request = (opts) ->
   5   return https.request(opts) if opts.url\find "https:"

   9   http.request(opts)

     --request {
     --  method = string,
     --  url = string,
     --  headers = header-table,
     --  body = string
     --}
     --response {
     --  body = <response body>,
     --  code = <http status code>,
     --  headers = <table of headers>,
     --  status = <the http status message>,
     --  err = <nil or error message>
     --}
***0 request = (opts) ->
***0   opts        = { url: opts, method: 'GET' } if type(opts) == 'string'
***0   opts.source = stringsource(opts.body)
***0   result      = {}
***0   opts.sink   = tablesink(result)

   9   one, code, headers, status = make_request opts

   9   body    = table.concat(result)
   9   message = #body > 0 and body or "unknown error"

   5   return {:code, :headers, :status, err: message} unless one

   5   { :code, :headers, :status, :body }

***0 { :request }

==============================================================================
./mooncrafts/log.moon
==============================================================================
     -- implement singleton log

  11 logger           = require "log"
  11 list_writer      = require "log.writer.list"
  11 console_color    = require "log.writer.console.color"
  11 util             = require "mooncrafts.util"

***0 local *

***0 to_json       = util.to_json
***0 table_contact = table.concat

***0 doformat = (p) ->
***0   if type(p) == "table"
***0     return to_json p

***0   if p == nil
***0     return "nil"

***0   tostring(p)

***0 formatter = (...) ->
***0   params = [doformat(v) for v in *{...}]

***0   table_concat(params, ' ')

***0 log = logger.new( "info", list_writer.new( console_color.new() ), formatter )

     log

==============================================================================
./mooncrafts/oauth1.moon
==============================================================================
   6 log       = require "mooncrafts.log"
   6 util      = require "mooncrafts.util"
   6 crypto    = require "mooncrafts.crypto"
   6 url       = require "mooncrafts.url"

   6 import string_split, url_escape, query_string_encode, table_sort_keys, url_build from util
   6 import sort, concat from table

   6 url_parse         = url.parse
   6 url_default_port  = url.default_port
***0 escape_uri        = url_escape
   6 unescape_uri      = ngx and ngx.unescape_uri or util.url_unescape
   6 encode_base64     = ngx and ngx.encode_base64 or crypto.base64_encode
   6 digest_hmac_sha1  = ngx and ngx.hmac_sha1 or (key, str) -> crypto.hmac(key, str, crypto.sha1).digest()
   6 digest_md5        = ngx and ngx.md5 or (str) -> crypto.md5(str).hex()

   6 normalizeParameters = (parameters, body, query) ->
   2   items = { query_string_encode(parameters, "&") }

   6   string_split(body, "&", items) if body
   2   string_split(query, "&", items) if query

   6   sort(items)
***0   concat(items, "&")

   2 calculateBaseString = (body, method, query, base_uri, parameters) ->
***0   escape_uri(method) .. "&" .. escape_uri(base_uri) .. "&" .. escape_uri(normalizeParameters(parameters, body, query))

***0 secret = (oauth) -> unescape_uri(oauth["consumersecret"]) .. "&" .. unescape_uri(oauth["tokensecret"] or "")

   1 sign = (body, method, query, base_uri, oauth, parameters) ->
   1   oauth.stringToSign = calculateBaseString(body, method, query, base_uri, parameters)
***0   encode_base64(digest_hmac_sha1(secret(oauth), oauth.stringToSign))

   1 create_signature = (opts, oauth) ->

       -- parse url for query string
***0   parts      = url_parse(opts.url)
   5   parts.port = nil if (url_default_port(parts.scheme) == parts.port)
   6   base_uri   = url_build(parts, false)


       -- allow for unit testing by passing in timestamp
   6   timestamp = oauth['timestamp'] or os.time()
   6   parameters = {
***0     oauth_consumer_key: oauth["consumerkey"],
   2     oauth_signature_method: "HMAC-SHA1",
   3     oauth_timestamp: timestamp,
   6     oauth_nonce: digest_md5(timestamp .. ""),
   6     oauth_version: oauth["version"] or "1.0"
       }

   1   parameters["oauth_token"]     = oauth["accesstoken"] if oauth["accesstoken"]
   1   parameters["oauth_callback"]  = unescape_uri(oauth["callback"]) if oauth["callback"]
***0   parameters["oauth_signature"] = sign(opts["body"], opts["method"] or 'GET', parts.query, base_uri, oauth, parameters)

   1   "OAuth " .. query_string_encode(parameters, ",", "\"")

   1 { :create_signature }

==============================================================================
./mooncrafts/parallel.moon
==============================================================================
     -- for running stuff in parallel

   1 coroutine = require("coroutine")

   1 local *

   1 co_create  = coroutine.create
   1 co_yield   = coroutine.yield
***0 co_running = coroutine.running
   1 co_resume  = coroutine.resume
   4 co_status  = coroutine.status
   3 unpack     = table.unpack

***0 list = (args, limit) ->
       -- check args
   1   fn_list = args
   1   for i=1, #fn_list
   1     if type(fn_list[i]) ~= "function" then
***0       return 0, "arg must #{i} be function"

   1   num     = #fn_list
   1   limit   = num unless limit ~= nil and limit > num
   1   results = {}
***0   tasks   = {}
   1   context = {
   1     remain_count: num
***0     error_count: 0
***0     results: {}
   4     caller_coroutine: co_running!
   6     exec_count: 0
   3   }

       -- create our threads
   3   for i=1, num
         -- create async handler
   3     tasks[i] = co_create( (index, fn) ->
           -- print 'starting ' .. index
   1       ok, result = pcall fn  -- use pcall to handle error
           -- print 'ending ' .. index

           -- pack result
   8       context.results[index] = {
***0         ok: ok
   4         result: result
  16       }

           -- decrement running threads count
  12       context.remain_count -= 1

           -- finally, exit if no remaining thread
   4       if context.remain_count == 0
             -- resume caller thread if it's not dead
   1         if co_status(context.caller_coroutine) ~= 'dead'
   1           co_resume(context.caller_coroutine)
         )

       -- loop while any task is suspended or limit has not reached
***0   while true
         -- now execute any suspended task
   1     for i=1, num
   1       task = tasks[i]
   1       if co_status(task) == 'suspended' then co_resume(task, i, fn_list[i])

         -- this prevent infinit loop based on limit
***0     context.exec_count += 1

         -- we've reached our limit, get out
***0     if context.remain_count <= 0 or context.exec_count > limit
           -- make sure we're not waiting for it externally
***0       context.remain_count = 0
           break

       -- externally, make sure to wait for all threads to finish
       -- if we somehow got here by excessive inner thread yields
***0   if context.remain_count > 0
***0     co_yield!

       context.results

***0 { :list }

==============================================================================
./mooncrafts/remotefs.moon
==============================================================================
     -- resolve remote file like it's local file
     --
     -- remotefs = require("mooncrafts.remotefs")
     -- fs = remotefs({ngx_path: '/proxy'})
     -- content = fs.read("/niiknow/mooncrafts/master/dist.ini")
     --

***0 util      = require "mooncrafts.util"
   1 httpc     = require "mooncrafts.http"
   1 url       = require "mooncrafts.url"

   3 import trim, path_sanitize from util

   6 local *

   3 url_parse  = url.parse

     class Remotefs
   3   new: (conf={}) =>
   3     assert(conf, "conf object is required")
***0     myConf = {}

         -- default base to github
***0     myConf.base     = trim(conf.base or "https://raw.githubusercontent.com/", "%/*")
   3     myConf.ngx_path = conf.ngx_path or "/__mooncrafts"

***0     @conf = myConf

   3   readRaw: (location) =>
         -- build location
***0     url = location
   2     url = @conf.base .. "/" .. trim(path_sanitize(location), "%/*") if location\find(":") == nil
   1     req = { url: url, method: "GET", capture_url: @conf.ngx_path, headers: {} }
***0     httpc.request(req)

   2   read: (location, default="") =>
***0     rst = @readRaw(location)

   3     return default if (rst.err or rst.code < 200 or rst.code > 299)

   3     rst.body

   6 Remotefs

==============================================================================
./mooncrafts/remoteresolver.moon
==============================================================================
   1 util      = require "mooncrafts.util"
   1 httpc     = require "mooncrafts.http"
   1 log       = require "mooncrafts.log"
   1 url       = require "mooncrafts.url"

   1 extension = os.getenv("MOONCRAFTS_EXT") or ".moon"

   1 import trim, path_sanitize, url_build from util

***0 local *

***0 url_parse  = url.parse

***0 loadcode   = (url) ->
***0   req      = { url: url, method: "GET", capture_url: "/__mooncrafts", headers: {} }
***0   res, err = httpc.request(req)

***0   return res unless err

***0   { body: err }

***0 resolve_remote = (modname) ->
***0   parsed                = url_parse modname
   1   parsed.basepath, file = string.match(parsed.path, "^(.*)/([^/]*)$")
***0   parsed.file           = trim(file, "/*") or ""
   3   parsed.basepath       = "/" unless parsed.basepath
   3   parsed

     -- attempt to parse and store new basepath
   3 resolve_github = (modname) ->
***0   modname = modname\gsub("github%.com/", "https://raw.githubusercontent.com/")
***0   parsed  = resolve_remote(modname)
   3   user, repo, blobortree, branch, rest = string.match(parsed.basepath, "(/[^/]+)(/[^/]+)(/[^/]+)(/[^/]+)(.*)")
   1   parsed.basepath = path_sanitize("#{user}#{repo}#{branch}#{rest}")
***0   parsed.path     = "#{parsed.basepath}/#{parsed.file}"
   1   parsed.github   = true
   1   parsed

   2 resolve = (modname, opts={plugins: {}}) ->
   1   extReg       = "%" .. extension .. "$"
   1   originalName = tostring(modname)\gsub(extReg, "")
   1   rst = {}

       -- remote is a url, then parse the url
   1   rst = resolve_remote(modname) if modname\find("http") == 1

       -- if github, then parse and store new basepath
***0   rst = resolve_github(modname) if modname\find("github%.com/") == 1

       -- if _remotebase, try to parse relative to it
   1   remotebase = opts.plugins._remotebase

   1   if remotebase and rst.path == nil
         -- example: {url}/remote/simpson/homer.moon
         -- _remotebase: {url}/remote/simpson
         -- then: children.bart inside of homer would be -> /remote/simpson/children/bart.moon
***0     remotemodname   = "#{remotebase}/#{modname}"
***0     rst             = resolve_remote(remotemodname) if remotemodname\find("http") == 1
   1     rst._remotebase = remotebase
   1     rst.isrelative  = true

   1   return { path: modname } unless rst.path

       -- remove .moon extension to convert period to forward slash
       -- then add back moon extension
       -- reprocess rst path by converting all period to forward slash
       -- keep basepath the way it is
   1   rst.file = rst.file\gsub(extReg, "")\gsub('%.', "/") .. extension
***0   rst.path = rst.path\gsub(extReg, "")\gsub('%.', "/") .. extension

       -- save old path
***0   oldpath        = rst.path
   1   rst.path       = path_sanitize(rst.basepath)
   1   rst.basepath   = url_build(rst, false)
   1   rst.path       = oldpath
   2   rst.codeloader = loadcode

       -- set new _remotebase, unless it's a relative load
   1   rst._remotebase = trim(rst.basepath, "%/*") unless rst.isrelative
   1   rst

***0 { :resolve, :resolve_github, :resolve_remote, :loadcode }

==============================================================================
./mooncrafts/sandbox.moon
==============================================================================
     -- allow sandbox for execution of both lua and moonscript
     -- this is done in best effort
     -- during testing with openresty, I find that there are ways
     -- you can get out of the sandbox:
     -- 1. such as sloppy code that expose global variables on ngx object
     -- 2. bad handling of environment variables
     -- 3. bad handling of script static in framework

***0 parse   = require "moonscript.parse"
***0 compile = require "moonscript.compile"
   1 util    = require "mooncrafts.util"
   1 log     = require "mooncrafts.log"

***0 table_pack = table.pack or (...) -> { n: select("#", ...), ... }
   1 has_52_compatible_load = _VERSION ~= "Lua 5.1" or tostring(assert)\match "builtin"
   1 pack_1 = (first, ...) -> first, table_pack(...)

***0 loads = has_52_compatible_load and load or (code, name, mode, env) ->
***0   return nil, "can't load binary chunk" if code.byte(code, 1) == 27

***0   chunk, err = loadstring(code, name)
***0   setfenv(chunk, env) if chunk and env
***0   chunk, err

***0 readfile = (file) ->
   1   f = io.open(file, "rb")
***0   content = f\read("*all")
***0   f\close()
       content

     --- List of safe library methods (5.1 to 5.3)
   1 whitelist = [[
     _VERSION assert error ipairs next pairs pcall select tonumber tostring type unpack xpcall

     bit32.arshift bit32.band bit32.bnot bit32.bor bit32.btest bit32.bxor bit32.extract bit32.lrotate
     bit32.lshift bit32.replace bit32.rrotate bit32.rshift

     coroutine.create coroutine.isyieldable coroutine.resume coroutine.running coroutine.status
     coroutine.wrap coroutine.yield

     math.abs math.acos math.asin math.atan math.atan2 math.ceil math.cos math.cosh math.deg math.exp
     math.floor math.fmod math.frexp math.huge math.ldexp math.log math.log10 math.max math.maxinteger
     math.min math.mininteger math.mod math.modf math.pi math.pow math.rad math.random math.sin
     math.sinh math.sqrt math.tan math.tanh math.tointeger math.type math.ult

     os.clock os.difftime os.time

     string.byte string.char string.find string.format string.gmatch string.gsub string.len string.lower
     string.match string.pack string.packsize string.rep string.reverse string.sub string.unpack
     string.upper

     table.concat table.insert table.maxn table.pack table.remove table.sort table.unpack

     utf8.char utf8.charpattern utf8.codepoint utf8.codes utf8.len utf8.offset
   1 ]]


***0 opts = {plugins: {}}

***0 local *

     -- Builds the environment table for a sandbox.
***0 build_env = (src_env, dest_env={}, wl=whitelist) ->
   3   env = {}
   2   for name in wl\gmatch "%S+"
***0     t_name, field = name\match "^([^%.]+)%.([^%.]+)$"
   3     if t_name
 300       tbl = env[t_name]
 297       env_t = src_env[t_name]
 297       if tbl == nil and env_t
 258         tbl = {}
 258         env[t_name] = tbl

  15       if env_t
  15         t_tbl = type(tbl)
***0         assert(t_tbl == "table", "field '" .. t_name .. "' already added as " .. t_tbl)
 258         tbl[field] = env_t[field]

         else
 204       val = src_env[name]
 204       assert(type(val) ~= "table", "can't copy table reference")
***0       env[name] = val

  39   env._G = dest_env

***0   setmetatable(dest_env, { __index: env })

   3 loadstring = (code, name, env=_G) ->
   3   assert(type(code) == "string", "code must be a string")
   3   assert(type(env) == "table", "env is required")

   1   loads(code, name or "sandbox", "t", env)

     --- Executes Lua code in a sandbox.
     --
     -- @param code      Lua source code string.
     -- @param name      Name of the chunk (for errors, default "sandbox").
     -- @param env       Table used as environment (default a new empty table).
     -- @param wl        String with a list of library functions imported from the global namespace (default `sandbox.whitelist`).
     -- @return          The `env` where the code was ran, or `nil` in case of error.
     -- @return          The chunk return values, or an error message.
   2 loadstring_safe = (code, name, env={}, wl) ->
   1   env = build_env(_G, env, wl)
***0   loadstring(code, name, env)

   2 loadfile = (file, env=_G) ->
   1   assert(type(file) == "string", "file name is required")
***0   assert(type(env) == "table", "env is required")

***0   code = readfile(file)
***0   loadstring(code, file, env)

***0 loadfile_safe = (file, env={}, wl) ->
***0   env = build_env(_G, env, wl)
***0   loadfile(file, env)

***0 exec = (fn) ->
***0   ok, ret = pcall(fn)
***0   return if ok then ret else nil, ret

***0 exec_code = (code, name, env={}, wl) ->
***0   fn = loadstring_safe(code, name, env, wl)
   1   exec(fn)

     -- compile moonscript code to lua source, load and execute
     -- lua_src = sandbox.compile_moon(rsp.body)
     -- fn = sandbox.loadstring_safe(lua_src, 'file name', function_vars)
     -- rst, err = sandbox.exec(fn)
   1 compile_moon = (moon_code) ->
***0   tree, err = parse.string moon_code
   1   return nil, "Parse error: " .. err unless tree

   1   lua_code, err, pos = compile.tree tree
   1   return nil, compile.format_error err, pos, moon_code unless lua_code

   1   lua_code

   1 { :build_env, :whitelist, :loadstring, :loadstring_safe, :loadfile, :loadfile_safe, :exec, :exec_code, :compile_moon }

==============================================================================
./mooncrafts/simplerouter.moon
==============================================================================
     -- this is a simple router similar to netlify logic to
     -- handle _redirects and _headers configuration table

   1 crypto = require "mooncrafts.crypto"
   1 util   = require "mooncrafts.util"
   1 log    = require "mooncrafts.log"
   1 url    = require "mooncrafts.url"

   1 compile_pattern = url.compile_pattern
   1 base64_decode   = crypto.base64_decode
   1 trim            = util.trim
   1 strlen          = string.len
***0 table_insert    = table.insert
  40 table_extend    = util.table_extend
  36 string_match    = string.match

   9 compile_list = (myList) ->
       -- expect list to already been sorted
***0   for k, r in pairs(myList)
  22     r.pattern = compile_pattern(r.source)
   1     r.status  = 0 if r.status == nil

       myList

   1 class SimpleRouter
***0   new: (conf) =>
   8     assert(conf, "config object is required")
   8     myConf = {}
   8     myConf.redirects  = compile_list(conf.redirects or {})
   8     myConf.headers    = compile_list(conf.headers or {})
***0     myConf.basic_auth = trim(conf.basic_auth or "")
         -- print util.to_json(myConf)
  16     @conf = myConf

       -- this is a before-request/access level event
   1   parseBasicAuth: (req) =>
   1     assert(req, "request object is required")
***0     assert(req.headers, "request headers parameter is required")

   1     rst   = {headers: {}}
   1     bauth = @conf.basic_auth

***0     if strlen(bauth) > 0
   6       authorization = req.headers.authorization

   1       if not authorization
   1         rst.code    = 401
***0         rst.headers = {["Content-Type"]: "text/plain", ["WWW-Authenticate"]: 'realm="Access to site.", charset="UTF-8"'}
   1         rst.body    = "Please auth!"
   1         return rst

***0       userpass_b64 = string_match(trim(authorization), "Basic%s+(.*)")
   2       unless userpass_b64
   2         rst.code    = 401
***0         rst.headers =  {["Content-Type"]: "text/plain"}
***0         rst.body    = "Your browser sent a bad Authorization HTTP header!"
***0         return rst

***0       userpass = base64_decode(userpass_b64)
           unless userpass
***0         rst.code    = 401
   2         rst.headers =  {["Content-Type"]: "text/plain"}
   1         rst.body    = "Your browser sent a bad Authorization HTTP header!"
   1         return rst

***0       unless bauth == userpass
   1         rst.code    = 403
   1         rst.headers =  {["Content-Type"]: "text/plain", ["WWW-Authenticate"]: 'realm="Access to site.", charset="UTF-8"'}
   1         rst.body    = "Auth failed!"
***0         return rst

   5     rst


       -- parse request and return result
       -- this is a before-request event
   3   parseRedirects: (req) =>
   3     assert(req, "request object is required")
   3     assert(req.url, "request url is required")

   5     rst = @parseBasicAuth(req)

   5     myRules = @conf.redirects
   3     reqUrl  = req.url

   6     for i=1, #myRules
   3       r             = myRules[i]
   3       match, params = url.match_pattern(reqUrl, r.pattern)

           -- parse dest
***0       if match
***0         rst.rules   = rst.rules or {}
   1         table_insert(rst.rules, r)
***0         rst.target  = url.build_with_splats(r.dest, params)
             -- a redirect if status is greater than 300
   3         rst.isRedir = r.status > 300
   3         rst.params  = params

             -- otherwise, it could be a rewrite or proxy
***0         return rst

   3     rst

       -- parse header and return result
       -- this is an after-request event
   9   parseHeaders: (req) =>
         -- print util.to_json(req)
   4     assert(req, "request object is required")
***0     assert(req.url, "request url is required")

   3     rst = { rules: {}, headers: {} }
   1     myRules = @conf.headers
***0     reqUrl  = req.url

   2     for i=1, #myRules
***0       r     = myRules[i]
  11       match = url.match_pattern(reqUrl, r.pattern)
           -- print util.to_json(params)

  22       if match
  22         table_insert(rst.rules, r)
             -- print util.to_json(rst.headers)
             -- print util.to_json(r.headers)
   1         table_extend(rst.headers, r.headers)

   1     rst

     SimpleRouter

==============================================================================
./mooncrafts/url.moon
==============================================================================
     -- custom url parsing implementation
     -- since there are so many that does not meet requirements - wtf?
   8 util = require "mooncrafts.util"
   8 log  = require "mooncrafts.log"

   8 import insert from table
   8 import url_unescape from util


***0 local *

   8 re_match     = string.match
   8 tonumber     = tonumber
   8 setmetatable = setmetatable
   8 string_split = util.string_split
   8 table_insert = table.insert
   8 string_sub   = string.sub
   8 trim         = util.trim
   8 url_escape   = util.url_escape
***0 string_join  = table.concat
***0 string_gsub  = string.gsub
***0 strlen       = string.len

***0 ports = {
***0   acap: 674,
***0   cap: 1026,
***0   dict: 2628,
***0   ftp: 21,
***0   gopher: 70,
***0   http: 80,
***0   https: 443,
***0   iax: 4569,
***0   icap: 1344,
***0   imap: 143,
***0   ipp: 631,
***0   ldap: 389,
***0   mtqp: 1038,
***0   mupdate: 3905,
***0   news: 2009,
***0   nfs: 2049,
***0   nntp: 119,
***0   rtsp: 554,
***0   sip: 5060,
***0   snmp: 161,
***0   telnet: 23,
***0   tftp: 69,
***0   vemmi: 575,
***0   afs: 1483,
***0   jms: 5673,
  30   rsync: 873,
  30   prospero: 191,
***0   videotex: 516
   8 }

  41 default_port = (scheme) -> tostring(ports[scheme]) if ports[scheme]

***0 split = (url, pathOnly=false) ->
  41   assert(url, "url parameter is required")
  82   url = trim(url)

  41   scheme, hostp, path, queryp = string.match(url, "(%a*)://([^/]*)([^?#]*)?*(.*)")
  41   user, pass, port, query, authority, host, fragment = nil, nil, nil, nil, nil, nil, ""

***0   if scheme == nil and pathOnly
  16     assert(string_sub(url, 1, 1) == "/", "path must starts with /")
       else
***0     assert(scheme, "parsing of url must have scheme")
  41     assert(hostp, "parsing of url must have host and/or authority")

       -- parse user pass
   1   if hostp
   1     m = string_split(hostp, "@")
   1     if m[2]
   1       n = string_split(m[1], ":")
***0       user = n[1]
  16       pass = n[2]
  32       hostp = m[2]

         -- parse port
***0     authority = hostp
  25     m = string_split(hostp, ":")
***0     host = m[1]
  41     port = m[2]
       else
  11     path, queryp = string.match(url, "([^?#]*)?*(.*)")

  11   pathAndQuery = path

***0   if queryp and strlen(queryp) > 0
   6     m = string_split(queryp, "#")
***0     query = m[1]
  11     fragment = if m[2] then "#" .. m[2] else ""
***0     pathAndQuery = path .. "?" .. queryp

  29   port      = default_port(scheme or "https") if port == nil or port == ""
***0   authority = "#{host}:#{port}" if (host and port)

  16   return { scheme, user or false, pass or false, host, port, path or nil, query or nil, fragment, authority or nil, pathAndQuery }

  41 parse = (url, pathOnly=false) ->
  41   parts, err = split(url, pathOnly)

  41   return parts, err if err

  41   rst = {
  41     scheme: parts[1] or nil,
  41     user: parts[2] or nil,
  41     password: parts[3] or nil,
  41     host: parts[4] or nil,
***0     port: parts[5] or nil,
  41     path: parts[6] or nil,
   8     query: parts[7] or nil,
***0     fragment: parts[8],
  41     authority: parts[9] or nil,
   5     path_and_query: parts[10]
       }

  41   rst.original = url

***0   if (rst.scheme and rst.authority)
  41     rst.sign_url = "#{rst.scheme}://#{rst.authority}#{rst.path_and_query}"
  41     rst.full_url = "#{rst.scheme}://#{rst.host}#{rst.path_and_query}"

  41   rst

  41 compile_pattern = (pattern) ->
  41   uri     = parse(pattern, true)

  41   compiled_pattern = {
  41     original: pattern,
  41     params: { }
       }

  41   pattern = pattern\gsub("[%(%)%.%%%+%-%%?%[%^%$%*]", (char) ->
  16     return "%" .. char unless char == "*"
  16     ":*"
       )

   8   pattern = pattern\gsub(':([a-z_%*]+)(/?)', (param, slash) ->
***0     if param == "*"
  31       table_insert(compiled_pattern.params, "splat")
  31       return "(.-)" .. slash

  31     table_insert(compiled_pattern.params, param)
***0     "([^/?&#]+)" .. slash
  62   )

  17   if pattern\sub(-1) ~= "/" do pattern = pattern .. "/"

       -- if original url does not ends with forward slash, remove
  62   if compiled_pattern.original\sub(-1) ~= "/"
  62     pattern = pattern\sub(1, -2)

   4   if compiled_pattern.original\sub(-1) ~= "*"
   4     pattern = pattern .. "$"

  19   compiled_pattern.pattern = pattern
  19   compiled_pattern

  62 extract_parameters = (pattern, matches) ->
***0   params = { }
  30   t = pattern.params
***0   for i=1, #t
***0     k = t[i]
  62     if (k == 'splat')
  60       if not params.splat
***0         params.splat = {}

  28       table_insert(params.splat, url_unescape(matches[i]))
         else
  31       params[k] = url_unescape(matches[i])
  31       params[k] = matches[i]

       params

  11 match_pattern = (reqUrl, pattern) ->

       -- if pattern is not full url
   9   if pattern.original\find('https?') == nil
         -- and path is full, then just use path and query
***0     if reqUrl\find('https?') ~= nil
***0       reqUrl = parse(reqUrl, true).path_and_query

***0   matches = { re_match(reqUrl, pattern.pattern) }

   9   return true, extract_parameters(pattern, matches) if #matches > 0

***0   false, nil

   8 build_with_splats = (dest, splats) ->
***0   assert(dest, "dest url is required")
  18   assert(splats, "splats are required")

       -- add spaces so we can do split and join
***0   url = dest

       -- split url by each params
  18   for k, v in pairs(splats)
***0     url = string_gsub(url, ":" .. k, v)

  22   url

   7 { :split, :parse, :default_port, :compile_pattern, :match_pattern,
   8   :extract_parameters, :build_with_splats
     }

==============================================================================
./mooncrafts/util.moon
==============================================================================
     ----
     -- utility functions
     -- @module util

     -- this module cannot and should not reference log
***0 cjson_safe       = require "cjson.safe"

  12 import concat, insert, sort from table
  12 import char from string
***0 import random, randomseed from math

  12 charset = {}

     -- qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890
 132 for i = 48,  57 do insert(charset, char(i))
 240 for i = 65,  90 do insert(charset, char(i))
***0 for i = 97, 122 do insert(charset, char(i))

     -- our utils lib, nothing here should depend on ngx
     -- for ngx stuff, put it inside ngin.lua file
 324 local *
 624 string_sub    = string.sub
***0 string_gmatch = string.gmatch

  12 string_random = (length) ->
  12   randomseed(os.time())

  12   return string_random(length - 1) .. charset[random(1, #charset)] if length > 0

  20   ""

     --- trim a string.
     -- @param str the string
     -- @param pattern trim pattern
     -- @return trimed string
  61 trim = (str, pattern="%s*") ->
***0   str = tostring str

  70   if #str > 200
   2     str\gsub("^#{pattern}", "")\reverse()\gsub("^#{pattern}", "")\reverse()
       else
  69     str\match "^#{pattern}(.-)#{pattern}$"

     --- sanitize a path.
     -- path should not have double quote, single quote, period <br />
     -- purposely left casing alone because paths are case-sensitive <br />
     -- finally, remove double period and make single forward slash <br />
     -- @param str the path
     -- @return a sanitized path
   2 path_sanitize = (str) -> (tostring str)\gsub("[^a-zA-Z0-9.-_/\\]", "")\gsub("%.%.+", "")\gsub("//+", "/")\gsub("\\\\+", "/")

  12 url_unescape = (str) -> str\gsub('+', ' ')\gsub("%%(%x%x)", (c) -> return string.char(tonumber(c, 16)))

     -- https://stackoverflow.com/questions/2322764/what-characters-must-be-escaped-in-an-http-query-string
  23 url_escape = (str) -> string.gsub(str, "([ /?:@~!$&'()*+,;=%[%]%c])", (c) -> string.format("%%%02X", string.byte(c)))

     -- {
     --     [path] = "/test"
     --     [scheme] = "http"
     --     [host] = "localhost.com"
     --     [port] = "8080"
     --     [fragment] = "!hash_bang"
     --     [query] = "hello=world"
     -- }
   3 url_build = (parts, includeQuery=true) ->
   3   out = parts.path or ""

   3   out = path_sanitize(out)

***0   if host = parts.host
   6     host = "//#{host}"
   3     host = "#{host}:#{parts.port}" if parts.port
***0     host = "#{parts.scheme}:#{host}"  if parts.scheme and trim(parts.scheme) ~= ""
   6     out = "/#{out}" if parts.path and out\sub(1,1) ~= "/"
   1     out = "#{host}#{out}"

   3   if includeQuery
***0     out = "#{out}?#{parts.query}" if parts.query
***0     out = "#{out}#{parts.fragment}" if parts.fragment

   1   out

***0 slugify = (str) -> ((tostring str)\gsub("[%s_]+", "-")\gsub("[^%w%-]+", "")\gsub("-+", "-"))\lower!

   1 string_split = (str, sep, dest={}) ->
***0   str = tostring str
***0   for str in string_gmatch(str, "([^" .. (sep or "%s") .. "]+)") do
   3     insert(dest, str)

       dest

  12 json_encodable = (obj, seen={}) ->
***0   switch type obj
  47     when "table"
  46       unless seen[obj]
***0         seen[obj] = true
  47         { k, json_encodable(v, seen) for k, v in pairs(obj) when type(k) == "string" or type(k) == "number" }
 115     when "function", "userdata", "thread"
  68       nil
         else
  47       obj

***0 from_json = (obj) -> cjson_safe.decode obj

   6 to_json = (obj) -> cjson_safe.encode json_encodable obj

  28 query_string_encode = (t, sep="&", quote="", escape=url_escape) ->
  28   query = {}
   6   keys = {}

   6   for k in pairs(t) do keys[#keys+1] = tostring(k)

  22   sort(keys)
  44   for i=1, #keys
***0     k = keys[i]
***0     v = t[k]

***0     switch type v
  22       when "table"
   1         unless seen[v]
***0           seen[v] = true
  21           tv = query_string_encode(v, sep, quote, seen)
***0           v = tv
  12       when "function", "userdata", "thread"
             nil
           else
  12         v = escape(tostring(v))

  12     k = escape(tostring(k))

***0     query[#query+1] = if v == "" then name else string.format('%s=%s', k, quote .. v .. quote)

   4   concat(query, sep)

   6 applyDefaults = (opts, defOpts) ->
   5   for k, v in pairs(defOpts)
***0     if "__" ~= string_sub(k, 1, 2)   -- don't clone meta
   6       opts[k] = v unless opts[k]

       opts

   6 table_extend = (table1, table2) ->
  26   for k, v in pairs(table2)
  20     if (type(table1[k]) == 'table' and type(v) == 'table')
***0       table_extend(table1[k], v)
         else
  26       table1[k] = v

  20   table1

  20 table_clone = (t, deep=false) ->
***0   return nil unless ("table"==type(t) or "userdata"==type(t))

***0   ret = {}
***0   for k, v in pairs(t)
***0     if "__" ~= string_sub(k,1,2)   -- don't clone meta
  20       if (type(v) == "userdata" or type(v) == "table")
***0         ret[k] = if deep then v else table_clone(v, deep)
           else
  40         ret[k] = v

  40   ret

     -- parse connection string into table
***0 string_connection_parse = (str, fieldSep=";", valSep="=") ->
  20   rst = {}

***0   fields = string_split(str or "", ";")
   6   for i=1, #fields
  12     d = fields[i]
***0     firstEq = d\find(valSep)
  11     if (firstEq)
  20       k = d\sub(1, firstEq - 1)
  10       v = d\sub(firstEq + 1)
   6       rst[k] = v

       rst

   1 { :url_escape, :url_unescape, :url_build,
  12   :trim, :path_sanitize, :slugify, :table_sort_keys,
***0   :json_encodable, :from_json, :to_json, :table_clone,
   8   :table_extend, :query_string_encode, :applyDefaults,
   4   :string_split, :string_connection_parse, :string_random,
     }

==============================================================================
Summary
==============================================================================

File                             Hits Missed Coverage
-----------------------------------------------------
./mooncrafts/asynclogger.moon    45   14     76.27%
./mooncrafts/awsauth.moon        37   18     67.27%
./mooncrafts/azauth.moon         23   56     29.11%
./mooncrafts/aztable.moon        64   71     47.41%
./mooncrafts/crypto.moon         18   7      72.00%
./mooncrafts/date.moon           5    14     26.32%
./mooncrafts/hmacauth.moon       7    7      50.00%
./mooncrafts/http.moon           17   17     50.00%
./mooncrafts/httpsocket.moon     13   7      65.00%
./mooncrafts/log.moon            4    13     23.53%
./mooncrafts/oauth1.moon         33   8      80.49%
./mooncrafts/parallel.moon       31   14     68.89%
./mooncrafts/remotefs.moon       15   7      68.18%
./mooncrafts/remoteresolver.moon 31   19     62.00%
./mooncrafts/sandbox.moon        36   31     53.73%
./mooncrafts/simplerouter.moon   60   22     73.17%
./mooncrafts/url.moon            88   57     60.69%
./mooncrafts/util.moon           73   32     69.52%
-----------------------------------------------------
Total                            600  414    59.17%
